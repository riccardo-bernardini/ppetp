-- WARNING: this file was automatically generated
-- from body-syntax.xsd.  Do not edit this file.
-- (Well, ok, you can edit it, but you will loose
-- your changes the next time the file is rigenerated)

with Schema.Schema_Readers;  use Schema.Schema_Readers;
with Schema.Validators;  use Schema.Validators;
with Input_Sources.Strings;  use Input_Sources.Strings;
with Schema.Schema_Grammar;  use Schema.Schema_Grammar;
with Unicode.Ces.Utf8;  use Unicode.Ces.Utf8;

pragma Elaborate_All(Schema.Schema_Readers);

package body body_grammar is
   CR     : constant Character := Character'Val(13);
   LF     : constant Character := Character'Val(10);
   Schema : Schema_Reader;
   Read   : String_Input;
   Local_Grammar : XML_Grammar;

   Grammar_Spec : String := 
        "<?xml version=""1.0"" encoding=""UTF-8""?>" & CR & LF
      & "<xs:schema xmlns:xs=""http://www.w3.org/2001/XMLSchema"" elementFormDefault=""qualified"">" & CR & LF
      & "  <xs:element name=""configuration"">" & CR & LF
      & "    <xs:complexType>" & CR & LF
      & "      <xs:sequence>" & CR & LF
      & "        <xs:element maxOccurs=""unbounded"" ref=""session""/>" & CR & LF
      & "      </xs:sequence>" & CR & LF
      & "    </xs:complexType>" & CR & LF
      & "  </xs:element>" & CR & LF
      & "  <xs:element name=""session"">" & CR & LF
      & "    <xs:complexType>" & CR & LF
      & "      <xs:sequence>" & CR & LF
      & "        <xs:element ref=""profile""/>" & CR & LF
      & "        <xs:element minOccurs=""0"" ref=""server""/>" & CR & LF
      & "        <xs:element ref=""output""/>" & CR & LF
      & "        <xs:element ref=""input""/>" & CR & LF
      & "      </xs:sequence>" & CR & LF
      & "      <xs:attribute name=""streamID"" use=""required"" type=""xs:integer""/>" & CR & LF
      & "    </xs:complexType>" & CR & LF
      & "  </xs:element>" & CR & LF
      & "  <xs:element name=""server"">" & CR & LF
      & "    <xs:complexType>" & CR & LF
      & "      <xs:attribute name=""address"" use=""required""/>" & CR & LF
      & "      <xs:attribute name=""port"" use=""required"" type=""xs:unsignedShort""/>" & CR & LF
      & "      <xs:attribute name=""id"" use=""required"" type=""xs:hexBinary""/>" & CR & LF
      & "    </xs:complexType>" & CR & LF
      & "  </xs:element>" & CR & LF
      & "  <xs:element name=""output"">" & CR & LF
      & "    <xs:complexType>" & CR & LF
      & "      <xs:sequence>" & CR & LF
      & "        <xs:element maxOccurs=""unbounded"" ref=""channel""/>" & CR & LF
      & "      </xs:sequence>" & CR & LF
      & "    </xs:complexType>" & CR & LF
      & "  </xs:element>" & CR & LF
      & "  <xs:element name=""channel"">" & CR & LF
      & "    <xs:complexType>" & CR & LF
      & "      <xs:sequence>" & CR & LF
      & "        <xs:element minOccurs=""0"" ref=""auth-data""/>" & CR & LF
      & "        <xs:element minOccurs=""0"" maxOccurs=""unbounded"" ref=""parameter""/>" & CR & LF
      & "      </xs:sequence>" & CR & LF
      & "      <xs:attribute name=""id"" use=""required"" type=""xs:integer""/>" & CR & LF
      & "      <xs:attribute name=""max-target"" type=""xs:integer""/>" & CR & LF
      & "    </xs:complexType>" & CR & LF
      & "  </xs:element>" & CR & LF
      & "  <xs:element name=""profile"">" & CR & LF
      & "    <xs:complexType>" & CR & LF
      & "      <xs:sequence>" & CR & LF
      & "        <xs:element minOccurs=""0"" maxOccurs=""unbounded"" ref=""parameter""/>" & CR & LF
      & "      </xs:sequence>" & CR & LF
      & "      <xs:attribute name=""name"" use=""required"">" & CR & LF
      & "        <xs:simpleType>" & CR & LF
      & "          <xs:restriction base=""xs:token"">" & CR & LF
      & "            <xs:enumeration value=""basic""/>" & CR & LF
      & "            <xs:enumeration value=""vandermonde""/>" & CR & LF
      & "          </xs:restriction>" & CR & LF
      & "        </xs:simpleType>" & CR & LF
      & "      </xs:attribute>" & CR & LF
      & "    </xs:complexType>" & CR & LF
      & "  </xs:element>" & CR & LF
      & "  <xs:element name=""parameter"">" & CR & LF
      & "    <xs:complexType>" & CR & LF
      & "      <xs:attribute name=""name"" use=""required""/>" & CR & LF
      & "      <xs:attribute name=""value"" use=""required""/>" & CR & LF
      & "    </xs:complexType>" & CR & LF
      & "  </xs:element>" & CR & LF
      & "  <xs:element name=""input"">" & CR & LF
      & "    <xs:complexType>" & CR & LF
      & "      <xs:sequence>" & CR & LF
      & "        <xs:element minOccurs=""0"" maxOccurs=""unbounded"" ref=""peer""/>" & CR & LF
      & "      </xs:sequence>" & CR & LF
      & "    </xs:complexType>" & CR & LF
      & "  </xs:element>" & CR & LF
      & "  <xs:element name=""peer"">" & CR & LF
      & "    <xs:complexType>" & CR & LF
      & "      <xs:sequence>" & CR & LF
      & "        <xs:element maxOccurs=""unbounded"" ref=""address""/>" & CR & LF
      & "        <xs:element minOccurs=""0"" maxOccurs=""unbounded"" ref=""channel""/>" & CR & LF
      & "        <xs:element minOccurs=""0"" ref=""auth-data""/>" & CR & LF
      & "      </xs:sequence>" & CR & LF
      & "      <xs:attribute name=""id"" use=""required""/>" & CR & LF
      & "      <xs:attribute name=""address-type"" use=""required"">" & CR & LF
      & "        <xs:simpleType>" & CR & LF
      & "          <xs:restriction base=""xs:token"">" & CR & LF
      & "            <xs:enumeration value=""ip""/>" & CR & LF
      & "            <xs:enumeration value=""ice""/>" & CR & LF
      & "          </xs:restriction>" & CR & LF
      & "        </xs:simpleType>" & CR & LF
      & "      </xs:attribute>" & CR & LF
      & "    </xs:complexType>" & CR & LF
      & "  </xs:element>" & CR & LF
      & "  <xs:element name=""address"">" & CR & LF
      & "    <xs:complexType>" & CR & LF
      & "      <xs:sequence>" & CR & LF
      & "        <xs:element minOccurs=""0"" maxOccurs=""unbounded"" ref=""parameter""/>" & CR & LF
      & "      </xs:sequence>" & CR & LF
      & "      <xs:attribute name=""address"" use=""required""/>" & CR & LF
      & "      <xs:attribute name=""port"" use=""required"" type=""xs:unsignedShort""/>" & CR & LF
      & "    </xs:complexType>" & CR & LF
      & "  </xs:element>" & CR & LF
      & "  <xs:element name=""auth-data"">" & CR & LF
      & "    <xs:complexType>" & CR & LF
      & "      <xs:sequence>" & CR & LF
      & "        <xs:element ref=""auth-profile""/>" & CR & LF
      & "        <xs:element minOccurs=""0"" maxOccurs=""unbounded"" ref=""auth-token""/>" & CR & LF
      & "      </xs:sequence>" & CR & LF
      & "    </xs:complexType>" & CR & LF
      & "  </xs:element>" & CR & LF
      & "  <xs:element name=""auth-profile"">" & CR & LF
      & "    <xs:complexType>" & CR & LF
      & "      <xs:attribute name=""name"">" & CR & LF
      & "        <xs:simpleType>" & CR & LF
      & "          <xs:restriction base=""xs:token"">" & CR & LF
      & "            <xs:enumeration value=""void""/>" & CR & LF
      & "            <xs:enumeration value=""token""/>" & CR & LF
      & "            <xs:enumeration value=""signed""/>" & CR & LF
      & "          </xs:restriction>" & CR & LF
      & "        </xs:simpleType>" & CR & LF
      & "      </xs:attribute>" & CR & LF
      & "      <xs:attribute name=""id"" type=""xs:integer""/>" & CR & LF
      & "    </xs:complexType>" & CR & LF
      & "  </xs:element>" & CR & LF
      & "  <xs:element name=""auth-token"">" & CR & LF
      & "    <xs:complexType>" & CR & LF
      & "      <xs:attribute name=""command"">" & CR & LF
      & "        <xs:simpleType>" & CR & LF
      & "          <xs:restriction base=""xs:token"">" & CR & LF
      & "            <xs:enumeration value=""stop""/>" & CR & LF
      & "            <xs:enumeration value=""start""/>" & CR & LF
      & "          </xs:restriction>" & CR & LF
      & "        </xs:simpleType>" & CR & LF
      & "      </xs:attribute>" & CR & LF
      & "      <xs:attribute name=""value"" use=""required"" type=""xs:hexBinary""/>" & CR & LF
      & "    </xs:complexType>" & CR & LF
      & "  </xs:element>" & CR & LF
      & "</xs:schema>" & CR & LF;
   function Grammar return XML_Grammar is
   begin
      return Local_Grammar;
   end Grammar;

begin
   Open(str => Grammar_Spec, encoding => Utf8_encoding, input => Read);
   Parse(Schema, Read);
   Close(Read);
   Local_Grammar := Get_Created_Grammar(Schema);
end body_grammar;
