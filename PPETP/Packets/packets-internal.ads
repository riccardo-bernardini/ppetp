with Network;              	use Network;
--with Auth.Credentials;     	use Auth.Credentials;
with Byte_Arrays;	   	use Byte_Arrays;
with PPETP;			use PPETP;
with Packets.Protocol.Data;	use Packets.Protocol.Data;
with Packets.Protocol.Command;	use Packets.Protocol.Command;
with Unchecked_Deallocation;

with PPETP.Attributes;		use PPETP.Attributes;



package Packets.Internal is

   -- Definition of packet type resulting from parsing --
   ------------------------------------------------------

   type Command_Class is (Data,    ACK,     NACK,    Start,
                          Stop,    Invalid, Timeout, Punch,
                          Hello,   Set_Default,      Redirect,
                          Forward);
   --
   -- Possible types of  packets resulting from parsing process.
   -- Data and Control packets correspond to the same type
   -- of packets of PPETP; Invalid packets are the result of parsing
   -- a packet with wrong syntax.
   --
   -- Timeout class is not generated as a result of the parsing
   -- process, but it can be generated by input task.  Although
   -- this is maybe a "mixing of levels", we declare the class
   -- Timeout here, in order to avoid an identical declaration
   -- in the Input task specification file.
   --


   type Internal_Command (Class : Command_Class) is
      record
         Source         : Sock_Addr_Type;
         Id	        : Peer_ID;
         Seq_Number     : PPETP.Command_Sequence_Number; -- used only for command
         Sub_Seq_Number : PPETP.Sub_Sequence_Number;

         case Class is
            when Data =>
               Data_Seq_Number : PPETP.Data_Sequence_Number;
               Sending_Ch : PPETP.Channel_ID;
               StreamID   : PPETP.Stream_ID;
               Payload    : Raw_Data;

            when Hello =>
               Hello_Peer_Cred : Access_Attribute_Class;
            when Set_Default =>
               Chann_Def : PPETP.Channel_ID;
               Default   : Byte_Array_Pt;
            when ACK =>
               Sequence_Num_ACKed : PPETP.Command_Sequence_Number;
               Sub_Seq_Num_ACKed  : PPETP.Sub_Sequence_Number;
            when NACK =>
               Sequence_Num_NACKed : PPETP.Command_Sequence_Number;
               Sub_Seq_Num_NACKed  : PPETP.Sub_Sequence_Number;
               NAcked_Reason       : ACK_Reason_Type;
            when Start =>
               Start_Channel      : PPETP.Channel_ID;
               Start_New_Peer     : Access_Attribute_Class;
               Start_Peer_Cred    : Access_Attribute_Class;
               Start_Puncturing   : Access_Attribute_Class;
               Start_Routing_Prob : Access_Attribute_Class;
            when Stop =>
               Stop_Channel  : PPETP.Channel_ID;
               Stop_Old_Peer : Access_Attribute_Class;
            when Punch =>
               NAT_Method     : Byte;
               NAT_Param      : Byte;
               Start_Too      : Boolean;
               Redirect_Too   : Boolean;
               Punch_NAT_Attr : Access_Attribute_Class;

               -- Used only if the Start_Too or Redirect_Too flag is true
               Punch_Channel      : PPETP.Channel_ID;
               Punch_New_Peer     : Access_Attribute_Class;
               Punch_Old_Peer     : Access_Attribute_Class;
               Punch_Peer_Cred    : Access_Attribute_Class;
               Punch_Puncturing   : Access_Attribute_Class;
               Punch_Routing_Prob : Access_Attribute_Class;
            when Redirect =>
               Redir_Channel      : PPETP.Channel_ID;
               Redir_New_Peer     : Access_Attribute_Class;
               Redir_Old_Peer     : Access_Attribute_Class;
               Redir_Peer_Cred    : Access_Attribute_Class;
               Redir_Puncturing   : Access_Attribute_Class;
               Redir_Routing_Prob : Access_Attribute_Class;

            when Forward =>
               --SourceID     : Peer_ID;
               Forward_Data : Byte_Array_Pt;

            when Invalid =>
               null;
            when Timeout =>
               null;

         end case;
      end record;

   type Internal_Command_Pt is access Internal_Command;

   procedure Free is new Unchecked_Deallocation (Internal_Command, Internal_Command_Pt);

end Packets.Internal;
